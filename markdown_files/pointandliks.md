# Указатель

Указатель по своей сути это переменная которая в себе хранит адрес на другую переменную

```c++
int main() {
    int x = 5;
    int* point = &x;
    ...
```
В данном кусочке кода мы создали переменную x типа int.
Операция `&x` берет адрес переменной.
Мы присвоили указателю point адрес переменной x.

`int*` означает тип данных указателя point.
Так как мы ей(указателю Point) присвоили адрес переменной x, которая имеет тип данных int, то указатель будет типа `int*`.

## Арифметика указателей.

Очередная причина почему мы указываем тип данных элемента на который ссылается указатель.

Но про нее писать мне лень.

##  Ссылки

Допустим мы хотим, чтобы на одну и ту же часть памяти указывали несколько переменных.


```c++
int main() {
    int x = 5; // создали переменную x которая равна 5
    int& y = x; // создали переменную y которая по факту тоже равна 5, так как она связана с той же ячейкой памяти что и x
    int& z = y; // теперь у нас три переменные(x, y, z) указывают на некоторую ячейку в памяти где находится 5. 
}
```

Вот и вся суть ссылок, мы просто создаем новую переменную, которая указывают на уже используемое место в памяти.

Еще можно добавить, что ссылки полезны при передаче в функцию.

Что нам нужно сделать, чтобы при передаче в функцию наш аргумент не копировался, а передовался по адресу?

Это можно реализовать либо с помощью указателей либо с помощью ссылок.

Вот синтаксис

```c++

int f(int& x) {
    x += 5;
    return x;
}


int f(int* x) {
    (*x) += 5;
    return *x;
}

int main() {

    int x = 0;
    int y = f(x);
    std::cout << x;
    return 0;
}

```


Например, если мы передали элемент по ссылке, то программа выведет 5, а если бы передали просто, с копированием, то программа вывела бы 0, так как сам элемент x из main просто перекопировался бы в x из функции f. То есть при передаче по ссылке наш x формально тот же x, что и в main.


Практическое задание:

Реализуем функцию swap, которая меняет значения двух переменных типа int друг с другом через указатель. 

```c++

void swap(int*x, int*y) {
    int z = *x;
    *x = *y;
    *y = z;
}

int main() {
    int x = 5, y = 10;
    swap(&x, &y);
    std::cout << x << " " << y; // 10 5
}

```

# Ключевое слово `const` в C++

В C++ квалификатор `const` позволяет объявлять неизменяемые объекты и защищать  
данные от непреднамеренных изменений. Однако он имеет разные нюансы, связанные  
с указателями, ссылками, выводом типов и современными возможностями языка.

## 1. Основы `const` и уровни константности

В языке различают **верхнеуровневую константность** (top‑level const) и  
**нижнеуровневую константность** (low‑level const). Верхнеуровневая  
константность применяется к самому объекту: если переменная объявлена как  
`const int x`, то значение `x` нельзя изменить. Нижнеуровневая константность  
используется в указателях и ссылках для защиты объекта, на который они  
ссылаются. Например, тип `int*`— обычный указатель, `const int*`—  
указатель на константу, а `int* const`— константный указатель;

Основные варианты:

| Объявление              | Значение                          |
|------------------------|-----------------------------------|
| `int* ptr`             | Обычный указатель на `int`        |
| `const int* ptr`       | Указатель на **константу**        |
| `int* const ptr`       | **Константный указатель**         |
| `const int* const ptr` | Константный указатель на константу |

- **Указатель на константу** (`const int* ptr`) не позволяет изменять  
  значение, но разрешает менять сам указатель.
- **Константный указатель** (`int* const ptr`) не допускает переназначение  
  указателя, но разрешает менять значение объекта.
- Если `const` указан и слева и справа от `*`, то указатель и объект  
  защищены.

## 2. Ссылки и `const`

Ссылки в C++ всегда являются нижнеуровневыми: `int&`— обычная ссылка,  
`const int&`— ссылка на константу. Верхнеуровневой константности у ссылок  
нет, так как ссылка всегда привязана к одному объекту. Поэтому  
`const int& ref` просто означает, что через эту ссылку нельзя изменить  
значение объекта.
