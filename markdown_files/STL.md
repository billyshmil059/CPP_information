
# ПРО STL

Разберу базу

# Контейнеры
### 1. Статический массив
Статический массив - массив, размер которого задается в самом начале и не изменяется потом.

В С++ статический массив называют array.
Находится он в одноимённом заголовочном файле.
`std::array<int, 10> arr` - объявление статического массива **std::array** размеров 10 из элементов типа **int**
Размер массива так же является частью типа наравне с int.
По своей сути это обертка над обычным Сишным массивом.

**std::array** имеет методы: `size()`, `begin()`, `end()`, `at()`, `front()`, `back()`.


`int a[n]` - объявление статического массива **a** размера **n** из элементов **int**

Такое объявление С-style и у него есть свои минусы.

- Выход за границы ведет к неопределенному определению, а **std::array** выбрасывает исключение при выходе за границы

- Встроенный массив передаётся в функции как указатель (размер теряется), **std::array** передаётся по значению или ссылке с сохранением размера
- `sizeof(a) / sizeof(a[0])` может не работать при передаче массива в функцию, `arr.size() ` работает всегда.

##### Подробнее про `sizeof(a) / sizeof(a[0])`.
Это выражение для вычисления количества элементов в C-style массиве
1. `sizeof(a)` возвращает общий размер массива в байтах.
2. `sizeof(a[0])` возвращает размер одного элемента массива в байтах.


### 2. Динамический массив
Динамическим называется массив, размер которого можно изменить в процессе выполнения программы.
Вектор - это динамический массив, который позволяет эффективно добавлять элементы в конце и удалять последние элементы.


В следующем коде создаются разные векторы и добавляются/удаляются элементы.

```
vector <int> a; // создание пустого вектора
vector <int> b(n); // создание пустого вектора и резервирование памяти для n элементов.
vector <int> c(n, 0); // создание пустого вектора из n нулей
a.push_back(5); 
a.push_back(3); 
a.pop_back(); // добавление 5 и 3 в вектор и удаление последнего элемента
```
Операции добавления и удаления элементов работают в векторе за O(1). На практике скорость работы с вектором такая же, как и с статистическим массивом.

Операции с памятью
- `a.capacity` - возвращает сколько памяти зарезервировано под новые элементы
- `a.reserve(n)` - резервирование памяти на n элементов в векторе
- Когда количество элементов в векторе превышает резерв, то резерв увеличивается вдвое(происходит автоматически)

### 3.Cписки
**Односвязный список** - структура данных, состоящая из элементов, содержащих кроме собственных данных, ссылку на следующий элемент списка.

**Двусвязный список** - структура данных, состоящая из элементов, содержащих кроме собственных данных, ссылку на следующий и предыдущий элемент списка.

В стандартной библиотеке С++ двусвязный список реализован как контейнер `std::list()`, а односвязный как `std::forward_list()`

Операции реализованные для `std::list()` в С++:
- **Добавление элемента в массив**: `push_back(value)`, `push_front(value)`, `insert(iterator, value)`
- **Удаление элемента в массив**: `pop_back()`, `pop_front()`, `erase(iterator)`, `clear()`.
- **Доступ к элементам**: `front()`, `back()` .
- **Размер и проверка на пустоту**: `size()`, `empty()`.

Все эти операции выполняются за O(1)


Операции реализованные для std::forward_list:
- **Добавление элемента в массив**: `push_back(value)`, `insert_after(it, value)`
- **Удаление элемента в массив**: `pop_front()`, `erase_after(it)`, `clear()`.
- **Доступ к элементам**: `front()`.
- **Размер и проверка на пустоту**: `size()`(появился в С++23, до этого `std::distance(fl.begin(), fl.end())` за O(n)), `empty()`.


Все эти операции выполняются за O(1)


### 4. Дэки стеки очереди

### 4.1 deque
deque — это последовательный контейнер, который позволяет эффективно добавлять и удалять элементы как в начале, так и в конце.

Операции реализованные для std::deque:

- **Доступ и проверка**: `empty()`, `size()`, `front()`, `back()`, `operator[]`.
- **Добавления и удаления**: `push_back(value)`, `push_front(value)`, `pop_front`, `pop_back()`.

Операции доступа и проверки работают за O(1), а операции добавления и удаления работают за O(1) амортиз.

### 4.2 stack and queue

Стек и очередь являются лишь адаптерами, под капотом у них `std::deque`.
Операции для них:
- `empty()`, `size()`
- `push(v)`
- `pop()`
- `front()`, `back()` для очереди
- `top()` для стека(то же самое, что и `back()`)

`pop()` у стека удаляет элемент с конца, а у очереди с начала.

Находится стек и очередь соответственно в `stack` и `queue`(речь идет с чем писать `#include`)

### 4.3 priority_queue

#### 1. Что это
* Контейнер‑адаптер, как `stack`/`queue`.
* Внутри хранит элементы в `std::vector`+ поддерживает **бинарную кучу**.
* Быстрый доступ к «главному» элементу (по умолчанию — наибольшему).

#### 2. Сложность операций
| Операция | Сложность |
|----------|-----------|
| `top()`  | **O(1)** |
| `push()` | **O(log n)** |
| `pop()`  | **O(log n)** |

#### 3. Общий шаблон

```cpp
std::priority_queue<
    T,                     // тип элементов
    std::vector<T>,        // контейнер‑основание
    std::less<T>           // компаратор (по умолчанию — max‑heap)
> pq;
```
#### Min-heap


```c++
std::priority_queue<T, std::vector<T>, std::greater<T>> pq;
```

### 5. Ассоциативные контейнеры: map, set, unordered_map, unordered_set и тд.

| Контейнер               | Описание                                  | Основан на           | Упорядоченность | Поиск         |
|-------------------------|-------------------------------------------|----------------------|-----------------|---------------|
| `std::set`              | Множество уникальных ключей               | Красно-черное дерево | Упорядочен      | O(log n)      |
| `std::multiset`         | Множество **неуникальных** ключей        | Красно-черное дерево | Упорядочен      | O(log n)      |
| `std::map`              | Пары ключ-значение (уникальные ключи)    | Красно-черное дерево | Упорядочен      | O(log n)      |
| `std::multimap`         | Пары ключ-значение (неуникальные ключи)  | Красно-черное дерево | Упорядочен      | O(log n)      |
| `std::unordered_set`    | Множество уникальных ключей               | Хеш-таблица          | Неупорядочен    | O(1) амортиз. |
| `std::unordered_multiset` | Множество неуникальных ключей          | Хеш-таблица          | Неупорядочен    | O(1) амортиз. |
| `std::unordered_map`    | Пары ключ-значение (уникальные ключи)    | Хеш-таблица          | Неупорядочен    | O(1) амортиз. |
| `std::unordered_multimap`| Пары ключ-значение (неуникальные ключи) | Хеш-таблица          | Неупорядочен    | O(1) амортиз. |


| Операция               | `map/set`        | `unordered_map/set`    |
| ---------------------- | ---------------- | ---------------------- |
| Вставка (`insert`)     | O(log n)         | O(1) амортиз.          |
| Удаление (`erase`)     | O(log n)         | O(1) амортиз.          |
| Поиск (`find`)         | O(log n)         | O(1) амортиз.          |
| Доступ по ключу (`[]`) | O(log n) (`map`) | O(1) (`unordered_map`) |


# Итераторы
Итератор в C++ — это объект, который позволяет перебирать элементы контейнера (например, vector, list, map) так же, как указатель перебирает элементы массива.

Итераторы делятся на пять категорий.
1. `Random access iterator`: ++, -, арифметика, <, >, <=, >=.
   (array, vector, deque)
2. `Bidirectional iterator`: ++, --.
   (list, set, map)
3. `Forward iterator`: ++.
   (forward_list, unordered_set, unordered_map)
4. `Input iterator`: ++, read-only.
5. `Output iterator`: ++, write-only.

Функции для работы с итераторами:

`void advance(Iterator& it, size_t n);` - взять итератор и передвинуть на заданное количество позиций вперед.

`size_t distance (Iterator f, Iterator l);` - расстояние между итераторами

`void iter_swap(Iterator i, Iterator j);` - swap итераторов

O(1) для RA iterator и O(n) для остальных.


